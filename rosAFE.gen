#pragma require "bass-genom3 >= 1.0"
#include "bassInterface.gen"
#include "rosAFEInterface.gen"

component rosAFE {
    version         "1.0";
    lang            "c";
    email	    "musabini@isir.upmc.fr";
    require         "genom3 >= 2.99.26";
    uses            bassInterface;
    provides        rosAFEInterface;

    native inputProcessors;
    native preProcessors;
    native flagMap;

    ids {

	inputProcessors inputProcessorsSt;
	preProcessors preProcessorsSt;

	flagMap flagMapSt;
	flagMap newDataMapSt;
    };

    exception e_noData;
    
    task init {
		codel <start> initIDS(out ::ids) yield ether;
    };

    task read {
        period      250ms;
    };

    task preProc {
        period      250ms;
    };

    activity GetBlocks(
      inout unsigned long nBlocks = 1 : "Amount of blocks, 0 for unlimited",
      in unsigned long nFramesPerBlock = 12000 : "Blocks size in frames",
      in long startOffs = -12000 : "Starting offset (past < 0, future > 0)",
      in unsigned long bufferSize_s = 10 : "Buffer size in seconds",
      in string name = "input" : "The name of the GetBlocks activity"
      ) {
        doc         "Get consecutive blocks of audio data from bass";
        task        read;
        interrupts  GetBlocks;  // Only one audio input can be exist simultaneously (mono or stereo)

        codel <start>   startGetBlocks(in name, in nFramesPerBlock, in startOffs, in bufferSize_s, inout inputProcessorsSt,
                            port in Audio, port out inputProcessorOutput) yield waitExec;
	
	// The state Machine, start
        codel <waitExec>    	waitExecGetBlocks( inout nBlocks, in nFramesPerBlock, port in Audio ) yield pause::waitExec, exec, stop;
        codel <exec>    	execGetBlocks( in name, in inputProcessorsSt ) yield waitRelease, stop;
        codel <waitRelease>    	waitReleaseGetBlocks( in name, inout flagMapSt ) yield pause::waitRelease, release, stop;
        codel <release>    	releaseGetBlocks( in name, inout inputProcessorsSt, out newDataMapSt, port out inputProcessorOutput) yield pause::waitExec, stop;
	// The state Machine, end

        codel <stop>    	stopGetBlocks( inout inputProcessorsSt, inout flagMapSt, inout newDataMapSt ) yield ether;

        throw   e_noData;
    };

    activity PreProc (
      in string name = "preProc1" : "The name of this preProc",
      in string upperDepName = "input" : "The name of the upper dependencie",
      in unsigned long fsIn = 44100 : "fsIn",
      in unsigned long fsOut = 44100 : "fsOut"
      ) {
        doc         "preProc";
        task        preProc;


        codel <start>   	startPreProc( in name, in upperDepName, in fsIn, in fsOut, inout preProcessorsSt, inout flagMapSt, inout newDataMapSt, in inputProcessorsSt ) yield waitExec, stop;
	
	// The state Machine, start
        codel <waitExec>    	waitExecPreProc ( in name, in upperDepName, inout newDataMapSt ) yield pause::waitExec, exec, ether, delete;
        codel <exec>    	execPreProc ( in name, in upperDepName, inout preProcessorsSt, out flagMapSt ) yield waitRelease;
        codel <waitRelease>    	waitReleasePreProc ( in name, inout flagMapSt ) yield pause::waitRelease, release, stop;
        codel <release>    	releasePreProc ( in name, inout preProcessorsSt, out newDataMapSt ) yield pause::waitExec, stop;
	// The state Machine, end

        codel <delete>    	deletePreProc( in name, inout preProcessorsSt) yield ether;
        codel <stop>    	stopPreProc( inout preProcessorsSt ) yield ether;

    };

    function RemoveProcessor (
	in string name = "name" : "The name of the processor to delete"
	) {
	doc         "Removes the flags of this processor";

	codel removeProcessor(in name, inout flagMapSt, inout newDataMapSt );
    };

    function Stop() {
        doc         "Stop all";
        interrupts  GetBlocks, PreProc;
    };
};
