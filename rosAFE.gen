#pragma require "bass-genom3 >= 1.0"
#include "bassInterface.gen"
#include "rosAFEInterface.gen"

component rosAFE {
    version         "1.0";
    lang            "c";
    email	    "musabini@isir.upmc.fr";
    require         "genom3 >= 2.99.26";
    uses            bassInterface;
    provides        rosAFEInterface;

    native inputProcessors;
    native preProcessors;
    native flagMap;

    ids {

	inputProcessors inputProcessorsSt;
	preProcessors preProcessorsSt;

	flagMap flagMapSt;
    };

    exception e_noData;
    
    task init {
		codel <start> initIDS(out ::ids) yield ether;
    };

    task read {
        period      250ms; //chosen arbitrarily for this example
    };

    task preProc {
        period      250ms; //chosen arbitrarily for this example
    };

    activity GetBlocks(
      inout unsigned long nBlocks = 1 : "Amount of blocks, 0 for unlimited",
      in unsigned long nFramesPerBlock = 12000 : "Blocks size in frames",
      in long startOffs = -12000 : "Starting offset (past < 0, future > 0)",
      in unsigned long bufferSize_s = 10 : "Buffer size in seconds"
      ) {
        doc         "Get consecutive blocks of audio data from bass";
        task        read;
        interrupts  GetBlocks;  // Only one audio input can be exist simultaneously (mono or stereo)

        codel <start>   startGetBlocks(in nFramesPerBlock, in startOffs, in bufferSize_s, inout inputProcessorsSt,
                            port in Audio) yield waitExec;
	
	// The state Machine, start
        codel <waitExec>    	waitExecGetBlocks(inout nBlocks, in nFramesPerBlock, port in Audio) yield waitExec, exec, stop;
        codel <exec>    	execGetBlocks(in inputProcessorsSt) yield waitRelease, stop;
        codel <waitRelease>    	waitReleaseGetBlocks(in flagMapSt) yield waitRelease, release, stop;
        codel <release>    	releaseGetBlocks(inout inputProcessorsSt) yield waitExec, stop;
	// The state Machine, end

        codel <stop>    stopGetBlocks(inout inputProcessorsSt) yield ether;

        throw   e_noData;
    };

    activity PreProc (
      in string name = "1st PreProc" : "The name of this PreProc",
      in unsigned long fsIn = 44100 : "fsIn",
      in unsigned long fsOut = 44100 : "fsOut"
      ) {
        doc         "preProc";
        task        preProc;


        codel <start>   startPreProc( inout name, inout preProcessorsSt ) yield waitExec, stop;
	
	// The state Machine, start
        codel <waitExec>    	waitExecPreProc(inout name) yield waitExec, exec, stop;
        codel <exec>    	execPreProc(inout name) yield waitRelease, stop;
        codel <waitRelease>    	waitReleasePreProc(inout name) yield waitRelease, release, stop;
        codel <release>    	releasePreProc(inout name) yield waitExec, stop;
	// The state Machine, end

        codel <stop>    stopPreProc(inout preProcessorsSt) yield ether;

        throw   e_noData;
    };

    function AddFlag (
	in string lowerDep = "output" : "The name of the lower dependencie filter",
	in string upperDep = "input" : "The name of the upper dependencie filter"
	) {
	doc         "Creates a flag betwen the lowerDep and upperDep";

	codel addFlag(inout lowerDep, inout upperDep, inout flagMapSt);
        };

    function StopAll() {
        doc         "Stop getting blocks";
        interrupts  GetBlocks;
        };
};
