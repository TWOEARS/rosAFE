#pragma require "bass-genom3 >= 1.0"
#include "bassInterface.gen"
#include "rosAFEInterface.gen"

component rosAFE {
    version         "1.0";
    lang            "c";
    email	    "musabini@isir.upmc.fr";
    require         "genom3 >= 2.99.26";
    uses            bassInterface;
    provides        rosAFEInterface;

    native inputProcessors;
    native preProcessors;
    native flagMap;

    ids {

	inputProcessors inputProcessorsSt;
	preProcessors preProcessorsSt;

	flagMap flagMapSt;
	flagMap newDataMapSt;
    };

    exception e_noData;
    
    task init {
		codel <start> initIDS(out ::ids) yield ether;
    };

    task read {
        period      250ms;
    };

    task preProc {
        period      250ms;
    };

    activity GetBlocks(
      inout unsigned long nBlocks = 1 : "Amount of blocks, 0 for unlimited",
      in unsigned long nFramesPerBlock = 12000 : "Blocks size in frames",
      in long startOffs = -12000 : "Starting offset (past < 0, future > 0)",
      in unsigned long bufferSize_s = 10 : "Buffer size in seconds",
      in string name = "input" : "The name of the GetBlocks activity"
      ) {
        doc         "Get consecutive blocks of audio data from bass";
        task        read;
        interrupts  GetBlocks;  // Only one audio input can be exist simultaneously (mono or stereo)

        codel <start>   startGetBlocks(in nFramesPerBlock, in startOffs, in bufferSize_s, inout inputProcessorsSt,
                            port in Audio) yield waitExec;
	
	// The state Machine, start
        codel <waitExec>    	waitExecGetBlocks( inout nBlocks, in nFramesPerBlock, port in Audio ) yield pause::waitExec, exec, stop;
        codel <exec>    	execGetBlocks( inout name, in inputProcessorsSt ) yield waitRelease, stop;
        codel <waitRelease>    	waitReleaseGetBlocks( inout name, inout flagMapSt ) yield pause::waitRelease, release, stop;
        codel <release>    	releaseGetBlocks( inout name, inout inputProcessorsSt, out newDataMapSt) yield pause::waitExec, stop;
	// The state Machine, end

        codel <stop>    stopGetBlocks( inout name, inout inputProcessorsSt) yield ether;

        throw   e_noData;
    };

    activity PreProc (
      in string name = "preProc1" : "The name of this preProc",
      in string upperDepName = "input" : "The name of the upper dependencie",
      in unsigned long fsIn = 44100 : "fsIn",
      in unsigned long fsOut = 44100 : "fsOut"
      ) {
        doc         "preProc";
        task        preProc;


        codel <start>   	startPreProc( inout name, inout upperDepName, inout fsIn, inout fsOut, inout preProcessorsSt, inout flagMapSt, inout newDataMapSt, in inputProcessorsSt ) yield waitExec, stop;
	
	// The state Machine, start
        codel <waitExec>    	waitExecPreProc ( inout name, inout upperDepName, inout newDataMapSt ) yield pause::waitExec, exec, stop;
        codel <exec>    	execPreProc ( inout name, inout upperDepName, inout preProcessorsSt, out flagMapSt ) yield waitRelease, stop;
        codel <waitRelease>    	waitReleasePreProc ( inout name, inout flagMapSt ) yield pause::waitRelease, release, stop;
        codel <release>    	releasePreProc ( inout name, inout preProcessorsSt, out newDataMapSt ) yield pause::waitExec, stop;
	// The state Machine, end

        codel <stop>    stopPreProc( inout name, inout preProcessorsSt ) yield ether;

        throw   e_noData;
    };

    function RemoveProcessor (
	in string name = "name" : "The name of the processor to delete"
	) {
	doc         "Removes the flags of this processor";

	codel removeDependencie(inout name, inout flagMapSt, inout newDataMapSt );
    };

    function Stop() {
        doc         "Stop all";
        interrupts  GetBlocks, PreProc;
    };
};
